# DP 动态规划

 
## 背包问题

###    01 背包

1.题目描述

有 N 件物品和一个容量为 V 的背包，每件物品有各自的价值且只能被选择一次，要求在有限的背包容量下，装入的物品总价值最大。




1.**状态f[i][j]定义：前 i 个物品，背包容量 j
下的最优解**

当前的状态依赖于之前的状态,可以理解为从初始状态f[0][0] = 0开始决策，有 N
件物品，则需要 N 次决 策，每一次对第 i件物品的决策，状态f[i][j]不断由之前的状态更新而来。

2.当前背包容量不够（j < v[i]），没得选，因此前 i
个物品最优解即为前 i−1个物品最优解：对应代码：f[i][j] = f[i - 1][j]。

3.当前背包容量够，可以选，因此需要决策选与不选第 i

个物品：

**``选第i个物品：f[i][j] = f[i - 1][j - v[i]] + w[i].``.**

**``不选第i个物品f[i][j] = f[i - 1][j]``**

代码示例：

```
for(int i = 1; i <= n; i++) // 循环物品个数
        for(int j = 1; j <= m; j++) // 循环装物体的体积
        {
            //  当前背包容量装不进第i个物品，则价值等于前i-1个物品
            if(j < v[i]) 
                f[i][j] = f[i - 1][j];
            // 能装，需进行决策是否选择第i个物品
            else    
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
        }  
```


### 完全背包
题目描述

有N种物品和一个容量是 V 的背包，每种物品都有无限件可用。
第 i 种物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**状态f[i][j]定义：在前i个物品中，背包容量为j的价值最大值**

```
for(int i = 1 ; i <=n ;i++)
for(int j = 0 ; j <=m ;j++)
{
    f[i][j] = f[i-1][j];
    if(j-v[i]>=0)
        f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
}


f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]);//01背包

f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);//完全背包问题

完全背包问题和01的最大区别就是物品可以无限使用

```






## 线性DP




### 区间DP



### 计树类DP




