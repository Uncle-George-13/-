# DP 动态规划

 
## 背包问题

###    01 背包

1.题目描述

有 N 件物品和一个容量为 V 的背包，每件物品有各自的价值且只能被选择一次，要求在有限的背包容量下，装入的物品总价值最大。




1.**状态f[i][j]定义：前 i 个物品，背包容量 j
下的最优解**

当前的状态依赖于之前的状态,可以理解为从初始状态f[0][0] = 0开始决策，有 N
件物品，则需要 N 次决 策，每一次对第 i件物品的决策，状态f[i][j]不断由之前的状态更新而来。

2.当前背包容量不够（j < v[i]），没得选，因此前 i
个物品最优解即为前 i−1个物品最优解：对应代码：f[i][j] = f[i - 1][j]。

3.当前背包容量够，可以选，因此需要决策选与不选第 i

个物品：

**``选第i个物品：f[i][j] = f[i - 1][j - v[i]] + w[i].``.**

**``不选第i个物品f[i][j] = f[i - 1][j]``**

代码示例：

```
for(int i = 1; i <= n; i++) // 循环物品个数
        for(int j = 1; j <= m; j++) // 循环装物体的体积
        {
            //  当前背包容量装不进第i个物品，则价值等于前i-1个物品
            if(j < v[i]) 
                f[i][j] = f[i - 1][j];
            // 能装，需进行决策是否选择第i个物品
            else    
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
        }  
```


### 完全背包
题目描述

有N种物品和一个容量是 V 的背包，每种物品都有无限件可用。
第 i 种物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**状态f[i][j]定义：在前i个物品中，背包容量为j的价值最大值**

```
for(int i = 1 ; i <=n ;i++)
for(int j = 0 ; j <=m ;j++)
{
    f[i][j] = f[i-1][j];
    if(j-v[i]>=0)
        f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
}


f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]);//01背包

f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);//完全背包问题

完全背包问题和01的最大区别就是物品可以无限使用

```






## 线性DP

### 最长上升子序列
题目：
给定一个长度为N的数列(w[N])，求数值严格单调递增的子序列的长度最长是多少。


**关键** 
**状态表示 ：f[i]表示从第一个数字开始算，以w[i]结尾的最大的上升序列。(以w[i]结尾的所有上升序列中属性为最大值的那一个)**

**状态计算（集合划分）：j∈(0,1,2,..,i-1), 在w[i] > w[j]时，f[i] = max(f[i], f[j] + 1)**

```
int mx = 1;    // 找出所计算的f[i]之中的最大值，边算边找
    for (int i = 0; i < n; i++) {
        f[i] = 1;    // 设f[i]默认为1，找不到前面数字小于自己的时候就为1
        for (int j = 0; j < i; j++) {
            if (w[i] > w[j]) f[i] = max(f[i], f[j] + 1);    // 前一个小于自己的数结尾的最大上升子序列加上自己，即+1
        }
        mx = max(mx, f[i]);
    }
```
### 最大公共子序列

#### 题目描述：给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。

```
f[i][j] 表示在第一个序列的前i个字母中出现并且在第二个序列的前j个字母中出现的最大值

状态计算： f[i][j] = max(f[i-1][j-1],f[i-1][j],f[i][j-1])

四个条件，判断依据是 a[i]  == b[j] 相等则f[i][j] = f[i-1][j-1] + 1;
不相等 则 f[i][j] = max(f[i-1][j],f[i][j-1])  不相等则两个不可能都是公共子序列中的一个，所以一定舍去一个。

for (int i = 1; i <= n; i++) { 遍历a数组
    for (int j = 1; j <= m; j++) { 遍历b数组
      if (a[i] == b[j]) {  
        f[i][j] = f[i - 1][j - 1] + 1;
      } else {
        f[i][j] = max(f[i - 1][j], f[i][j - 1]);
      }


```


### 区间DP

#### 石子合并
合并 N 堆石子，每次只能合并相邻的两堆石子，求最小代价

```
状态表示 f[i][j] : 从第i堆合并到第j堆所需要的最小代价 结果就是 f[1][n];

状态计算 : 分成两部分，左边和右边，左边的，可以理解为第k个位置的左边和右边

模板

for (int len = 1; len <= n; len++) {         // 区间长度
    for (int i = 1; i + len - 1 <= n; i++) { // 枚举起点
        int j = i + len - 1;                 // 区间终点
        if (len == 1) {
            dp[i][j] = 初始值
            continue;
        }

        for (int k = i; k < j; k++) {        // 枚举分割点，构造状态转移方程
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]); // 有一个前缀和的数组
        }
    }
}







```


### 计树类DP




